#' @param taxids a vector of taxids
#'
#' @return ascend a vector of taxids
#'
#' @import jsonlite
#'
#' @export
#'
#' @examples get_ascend(2)
#'
get_ascend<-function(taxids) {
taxids<-as.character(taxids)
ascend<-NULL
i<-1
while(i<=length(taxids)) { #for each taxid in vector by group of 100
# url cannot be too long, so that we need to cut the taxids
# (100 max in one chunk)
# and make as many requests as necessary
cat(".")
taxids_sub<-taxids[i:(i+99)]
taxids_sub<-taxids_sub[!is.na(taxids_sub)] # remove NA values
taxids_sub<-paste(taxids_sub, collapse="%20") # accepted space separator in url
url<-paste("http://lifemap-ncbi.univ-lyon1.fr/solr/addi/select?q=taxid:(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="") #get all taxids of ascendant groups in database
# do the request from Solr
data_sub<-fromJSON(url)
if (data_sub$response$numFound!=0) { # if query succeeded
for (j in data_sub$response$docs[,"ascend"]) { # ascend is the taxid of ascendant groups
ascend<-append(ascend,j) # add each taxid to the list of results
}
}
i<-i+100
}
return(ascend)
}
#' @examples add_markers(data.frame(list(c('A','B','C'),c(300,20,109))), newmap(solr_request(2, "ncbi"), "ncbi"))
#' @param cluster if user wants cluster ; "none" by default
#'
#' @return mark_lifemap the lifemap with markers
#'
#' @import leaflet
#'
#' @export
#'
#' @examples add_markers(data.frame(list(c('A','B','C'),c(300,20,109))), newmap(solr_request(2, "ncbi"), "ncbi"))
#'
add_markers <- function(marks=NULL, lifemap, radius=10, popup="none",form="none",cluster="none"){
switch(popup, # choice of popup
"dataframe"={ # if user wants to use his own dataframe
for (i in marks){
elm<-as.vector(t(i))
if (is.character(elm)){ # the last vector of characters is used as popups
popup=elm
}
}
},
"sci_info"={ # if the user wants data from database Solr
popup=~paste(sep="<br/>",sci_name,taxid,nbdesc) # scientific name, taxid and number of descendants are used as popups
},
# new popups can be added here, as a new switch case
"none"={ # if popup is none, there is no popup
popup=NULL
}
)
switch(cluster, # choice of cluster
"sum"={ # if sum of groups is chosen
clusterOptions=markerClusterOptions() # cluster will display the number of groups clustered
},
"none"={ # if cluster is none, there is no cluster
clusterOptions=NULL
}
)
switch(form, # choice of icon form
"dataframe"={ # if user wants to use his own dataframe for the size of markers
for (i in marks){
elm<-as.vector(t(i))
if (is.numeric(elm)){ # the last vector of numeric is used as radius
radius<-elm/10
}
}
# creation of circle for each group, with previous options
mark_lifemap<-addCircleMarkers(lifemap, lng=~lon, lat=~lat, radius=radius, color='red', stroke=TRUE, fillOpacity=0.5, popup=popup, label=~sci_name,clusterOptions=clusterOptions)
},
"nbdesc"={ # if user wants to use number of descendants as radius
mark_lifemap<-addCircleMarkers(lifemap, lng=~lon, lat=~lat, radius=(~nbdesc+1), color="blue", stroke=TRUE, popup=popup, label=~sci_name,clusterOptions=clusterOptions)
},
# new markers form can be added here, as a new switch case
"none"={ # if form is none, simple arrow is used
mark_lifemap<-addMarkers(lifemap, lng=~lon, lat=~lat, popup=popup,label=~sci_name,clusterOptions=clusterOptions)
}
)
return(mark_lifemap)
}
#' @return mark_lifemap the lifemap with markers
#'
#' @import curl
#'
#' @export
#'
#' @examples marklifemap(data.frame(list("taxid"=c(2,9443,2087),"name"=c('A','B','C'),"nbdesc"=c(300,20,109))), map='ncbi')
#'
#'
#'
marklifemap<-function(data,type="taxid", map='standard', minimap=FALSE, ascendant=FALSE, descendant=FALSE, popup="none", form="none", cluster="none"){
if (typeof(data)=="list"){
datanames<-colnames(data)
datanames<-datanames[datanames!=type]
taxids<-as.vector(t(data[type]))
marks<-data[datanames]
}
else {
taxids<-data
}
coordinates<-solr_request(taxids,type, map)
if (descendant) {
DATA<-get_descend(taxids)
desc<-solr_request(DATA,type,map) #add taxids of descendant groups if option is selected
coordinates<-merge(coordinates,desc,all=TRUE)
}
if (ascendant) {
DATA<-get_ascend(taxids)
asc<-solr_request(DATA,type,map)
coordinates<-merge(coordinates,asc,all=TRUE)
}
lifemap<-newmap(coordinates, map) # create lifemap
mark_lifemap<-add_markers(marks, lifemap,popup=popup,form=form,cluster=cluster) # marks lifemap
if (minimap) {
mark_lifemap<-add_minimap(mark_lifemap, map) # adds a little map if option is selected
}
return(mark_lifemap)
}
#' @param taxids a vector of numeric corresponding to taxids
#' @param i a numeric tracking the position of the taxids
#'
#' @return TRUE
#'
#' @export
#'
#'@examples library(jsonlite)
#'@examples map_and_data(fromJSON("http://lifemap-ncbi.univ-lyon1.fr/solr/taxo/select?q=taxid:(2%209443%202087)&wt=json&rows=1000"), c(2,9443,2087), 1)
#'
map_and_data <- function(data_sub, taxids, i){
if (length(taxids) - i >= 100){
# if the list of taxid is longer than 100 and there are more than 100 taxids left
if (data_sub[["response"]][["numFound"]] != 100){
# if there are invalid taxids in the url, print them
print("couldn't find following taxids:")
for (k in i:(i+99)){
if ((taxids[k] %in% data_sub[["response"]][["docs"]][1][["taxid"]]) == FALSE)
print(taxids[k])
}
}
else{
# if all taxids of the url were found
print("found all")
}
}
else if (i >= 101){
# if the list of taxid is longer than 100 and there are less than 100 taxids left
if (data_sub[["response"]][["numFound"]] != (length(taxids) - (i-1))) {
print("couldn't find following taxids:")
for (m in i:(length(taxids))){
if ((taxids[m] %in% data_sub[["response"]][["docs"]][1][["taxid"]]) == FALSE)
print(taxids[m])
}
}
else
print("found all")
}
else{
# if the list of taxid is shorter than 100
if (data_sub[["response"]][["numFound"]] != length(taxids)){
print("couldn't find following taxids:")
for (k in (1:(length(taxids)))){
if ((taxids[k] %in% data_sub[["response"]][["docs"]][1][["taxid"]]) == FALSE)
print(taxids[k])
}
}
else
print("found all")
}
return(TRUE)
}
#' Solr request
#'
#' Function to do a request from the database Solr to get the coordinates
#' Solr request
#'
#' Function to do a request from the database Solr to get the coordinates
#' of each taxon (taxids given).
#'
#' Solr request
#'
#' Function to do a request from the database Solr to get the coordinates
#' of each taxon (taxids given).
#'
#' @param taxids a vector of taxids
#' @param type a character string for the type of data used
#' Solr request
#'
#' Function to do a request from the database Solr to get the coordinates
#' of each taxon (taxids given).
#'
#' @param taxids a vector of taxids
#' @param type a character string for the type of data used
#' @param map a character string for a lifemap, "standard" by default
#'
#' Solr request
#'
#' Function to do a request from the database Solr to get the coordinates
#' of each taxon (taxids given).
#'
#' @param taxids a vector of taxids
#' @param type a character string for the type of data used
#' @param map a character string for a lifemap, "standard" by default
#'
#' @return coordinates of each taxid
#'
#' Function to do a request from the database Solr to get the coordinates
#' of each taxon (taxids given).
#'
#' @param taxids a vector of taxids
#' @param type a character string for the type of data used
#' @param map a character string for a lifemap, "standard" by default
#'
#' @return coordinates of each taxid
#'
#' @import jsonlite
#'
#'
#' @param taxids a vector of taxids
#' @param type a character string for the type of data used
#' @param map a character string for a lifemap, "standard" by default
#'
#' @return coordinates of each taxid
#'
#' @import jsonlite
#'
#' @export
#'
solr_request<-function(taxids, map='standard') {
coordinates<-NULL # coordinates of taxids in the lifemap
solr_request<-function(taxids,type="taxid", map='standard') {
taxids<-as.character(taxids)
coordinates<-NULL
i<-1
while(i<=length(taxids)) {
# url cannot be too long, so that we need to cut the taxids
# (100 max in one chunk)
# and make as many requests as necessary
cat(".")
taxids_sub<-taxids[i:(i+99)]
taxids_sub<-taxids_sub[!is.na(taxids_sub)]
taxids_sub<-paste(taxids_sub, collapse="%20") # accepted space separator in url
switch(map,
"ncbi"={
url<-paste("http://lifemap-ncbi.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"standard"={
url<-paste("http://lifemap.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"virus"={
url<-paste("http://virusmap.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"french"={
url<-paste("http://lifemap-fr.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
}
)
# do the request from Solr
data_sub<-fromJSON(url)
map_and_data(data_sub,taxids, i)
if (data_sub[["response"]][["numFound"]] != 0)
coordinates<-rbind(coordinates,data_sub$response$docs[,c("taxid","lon","lat", "sci_name","zoom","nbdesc")])
i<-i+100
}
for (j in 1:ncol(coordinates)) coordinates[,j]<-unlist(coordinates[,j])
class(coordinates$taxid)<-"character"
return(coordinates)
}
q
solr_request<-function(taxids,type="taxid", map='standard') {
taxids<-as.character(taxids) # change to characters
coordinates<-NULL # coordinates of taxids in the lifemap
i<-1
while(i<=length(taxids)) {
# url cannot be too long, so that we need to cut the taxids
# (100 max in one chunk)
# and make as many requests as necessary
cat(".")
taxids_sub<-taxids[i:(i+99)]
taxids_sub<-taxids_sub[!is.na(taxids_sub)]
taxids_sub<-paste(taxids_sub, collapse="%20") # accepted space separator in url
switch(map,
"ncbi"={
url<-paste("http://lifemap-ncbi.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"standard"={
url<-paste("http://lifemap.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"virus"={
url<-paste("http://virusmap.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
},
"french"={
url<-paste("http://lifemap-fr.univ-lyon1.fr/solr/taxo/select?q=",type,":(",taxids_sub,")&wt=json&rows=1000",sep="", collapse="")
}
)
# do the request from Solr
data_sub<-fromJSON(url)
map_and_data(data_sub,taxids, i)
if (data_sub[["response"]][["numFound"]] != 0)
coordinates<-rbind(coordinates,data_sub$response$docs[,c("taxid","lon","lat", "sci_name","zoom","nbdesc")])
i<-i+100
}
for (j in 1:ncol(coordinates)) coordinates[,j]<-unlist(coordinates[,j])
class(coordinates$taxid)<-"character"
return(coordinates)
}
